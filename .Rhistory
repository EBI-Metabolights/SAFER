output$state.description <- renderText({
if (is.null(values$selectedRange))
{
sel.rng <- values$selectedRange
} else {
sel.rng <- round(values$selectedRange, 3)
sel.rng <- paste0(sel.rng[1], '-', sel.rng[2], ' ppm')
}
paste0('\n\tselected row (compound): ', values$selectedRow %>% refs$name[.],
'\n\tselected cols: ', length(values$selectedCols),
'\n\tselectedRange: ', sel.rng)
})
output$stack.ref.feats <- renderPlot({
# Check we have the necessary filters ####
req(values$selectedRow)
req(values$selectedCols)
req(values$selectedRange)
req(ppm.tolerance)
req(vshift)
req(hshift)
message('\n\nTrying stackplot for')
# Which compound? ####
if (is.null(values$selectedRow)) {return(NULL)}
message('\t', values$selectedRow %>% refs$name[.])
# Which samples? - is there a sample selection? ####
if (is.null(values$selectedCols)) {return(NULL)}
message('\tin ', length(values$selectedCols), ' samples...')
# If all those pieces are in place, go on to selecting evidence: ####
metab.evidence <- select.evidence_refmet(ref = values$selectedRow %>% refs[.,],
sample = values$selectedCols %>% samples[.,],
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# # Spectral data:
#   xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
rf.fits <- metab.evidence$rf.fits
# Does any evidence exist for that ref in those samples?? ####
if(is.null(rf.fits)){message('\tno evidence for this region'); return(NULL)
} #else {message('\tselected ', length(rf.fits$fit.xrow), ' spec-features.')}
# Which ref feats ranges intersect selected ppm rng within tolerance? ####
# message('\t', c(rf.fits$fit.rngs) %>% range %>% round(3) %>% paste(., collapse = " - "), ' ppm')
out.of.range <- apply(rf.fits$fit.rngs, 2, function(rf.rng)
{range.intersect(rf.rng, values$selectedRange) %>% is.na %>% all}) %>% unlist
in.range <- !out.of.range
# Plot the backfit stackplot ref features that matched to those ppm points ####
if (any(in.range)){
message('Plotting ', sum(in.range), ' ref-feature x spectrum associations\n',
'\tfor region ',
round(values$selectedRange[1], 3), '-', round(values$selectedRange[2], 3), ' ppm\n',
'\tin ', length(values$selectedCols), ' samples...\n',
'\tPlease wait (plotting more spectra and/or wider regions takes more time)...\n')
bfs <- list(fit.feats = rf.fits$fit.feats[in.range, , drop = F],
fit.positions = rf.fits$fit.positions[in.range, , drop = F],
fit.xrow = rf.fits$fit.xrow[in.range],
pass.fit = T)
# Compute the feature stackplots ####
plt.pars <- list(vshift = 1, pixels = c(512, 512), pointsize = 0, interpolate = T, exp.by = 0.05)
# bfs$fit.feats <- bfs$fit.feats[1:71,]
# bfs$fit.positions <- bfs$fit.positions[1:71,]
# bfs$fit.xrow <- bfs$fit.xrow[1:71]
return(fastStack.withFeatures(xmat, ppm, raster = T, bfs = bfs, plt.pars))
# p <- project_features.stackplot(xmat, ppm,
#                                  label = NULL,
#                                  bestfits = bfs,
#                                  exp.by = 0.05, # ppm
#                                  vshift = vshift, # pass as slide bar?
#                                  hshift = hshift, # pass as slide bar?
#                                  sort.rows = F)
}
message("\tnothing in range (+\\- ppm match tolerance; ", ppm.tolerance,')...'); return(NULL)
})
####### Server-side compound selectizing ####
# Update selectizer ####
observeEvent(input$outputType, # look in outputType (from selectInput)
{
if(req(input$outputType == "Search for compound...")){
updateSelectizeInput(session,"compound.selection",
"Type/Select metabolite name (first one will be used)",
choices=unique(refs$name), server=T,
options = list(maxOptions = 5,
maxItems = 1,
placeholder = 'Start typing...'))
# Set working values based on this selection
output$selectized.compound <- renderText({paste0('selectized: ', input$compound.selection)})
}
}
)
# Get value from selectizer choice, map to row index ####
observeEvent(input$compound.selection, {
message("selectizer: ", input$compound.selection)
selectedRows <- which(refs$name == input$compound.selection) # in terms of matrix row inds
if (length(selectedRows) == 0){
message('compound name mismatch?')
values$selectedRow <- NULL
}
if (length(selectedRows) > 1){
message('Multiple compounds have name: ', refs$name[selectedRows[1]])
message('\tchoosing one with best overall score...')
row.bestscore <- mat[selectedRows, , drop = F] %>% rowSums %>% which.max %>% selectedRows[.]
message('Row ', row.bestscore, ' selected')
values$selectedRow <- row.bestscore
} else {
message('Row ', selectedRows[1], ' selected')
values$selectedRow <- selectedRows[1]
}
# Reset plotly data for our feeder plots
values$selectedCols <- NULL
values$selectedRange <- NULL
})
}
shinyApp(ui, server)
shinyApp(ui, server)
sel.rng <- c(7.1, 7.3)
ref.ind = (lib.info$Compound.Name %in% 'Tyramine') %>% which
ref.ind = (lib.info$Compound.Name %in% 'Tyramine') %>% which %>% .[1]
spec.ind = 1:150
# Matrix inds, but we need to pull out match inds, so actual ref number needed
ref.inds <- ref.ind %>% refs[.,]
lib.data.processed[[refs$number[ref.ind]]]$compound.name
ref.ind
ref.ind %>% refs[.,]
ref.ind = (lib.info$Compound.Name %in% 'Tyramine') %>% which %>% .[2]
ref.ind
(refs$name %in% 'Tyramine') %>% which %>% .[1]
ref.ind = (refs$name %in% 'Tyramine') %>% which %>% .[1]
spec.ind = 1:150
# Matrix inds, but we need to pull out match inds, so actual ref number needed
ref.inds <- ref.ind %>% refs[.,]
lib.data.processed[[refs$number[ref.ind]]]$compound.name
# Likewise, we need to unsort the sample (column) inds
spec.inds <- spec.ind %>% samples[.,]
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
# One of these lists for each sample selected
rfs.selection <- rfs.used$score.mat.coords$ref == ref$id &
rfs.used$score.mat.coords$ss.spec %in% sample$number
!any(rfs.selection)
inds <- match.info$id %in% (rfs.used$tot[rfs.selection] %>% unlist) # inds not always = ids
match.info <- match.info[inds, ]
backfits <- backfits[inds ]
correct.refnum <- match.info$ref == ref$id
correct.refnum <- match.info$ref == ref$id
match.info <- match.info[correct.refnum, ]
backfits <- backfits[correct.refnum ]
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
ref.inds
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
ref$id
match.info$ref == ref$id
source("~/Documents/GitHub/icl_nmr_R/R/select.evidence_refmet.R")
metab.evidence <- select.evidence_refmet(ref = ref.inds,
sample = spec.inds,
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# Spectral data:
# xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
rf.fits <- metab.evidence$rf.fits
# message('\t', c(rf.fits$fit.rngs) %>% range %>% round(3) %>% paste(., collapse = " - "), ' ppm')
out.of.range <- apply(rf.fits$fit.rngs, 2, function(rf.rng)
{range.intersect(rf.rng, sel.rng) %>% is.na %>% all}) %>% unlist
if(is.null(rf.fits)){message('\tno evidence for this region'); return(NULL)
}
metab.evidence <- select.evidence_refmet(ref = values$selectedRow %>% refs[.,],
sample = values$selectedCols %>% samples[.,],
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# # Spectral data:
#   xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
# Server ####
server <- function(input, output, session) {
values <- reactiveValues(selectedRow = NULL,
selectedCols = NULL,
selectedRegion = NULL)
####### Right-side stuff ######
# Make heatmap
output$heat <- renderPlotly({
# Plot_ly add_heatmap (but how to select???) ####
drawHeatmap(mat, source.name = "heatmap", dropRowNames = F) %>%
event_register("plotly_click")
})
# Select row from heatmap
sel.row.from.heatmap <- reactive({
clickData <- event_data("plotly_click", source = "heatmap")
if (length(clickData) == 0) {
return(NULL)
} else {
clickData <- clickData %>% as.list
message('Row ', clickData$pointNumber[[1]][1] + 1, ' selected from heatmap click')
clickData$pointNumber[[1]][1] + 1
}
})
# Update values$selectedRow if sel.row.from.heatmap was updated
observeEvent(sel.row.from.heatmap(), {
values$selectedRow <- sel.row.from.heatmap()
# Reset plotly data for our feeder plots
values$selectedCols <- NULL
values$selectedRange <- NULL
})
# Format compound (row) name for printing as title
output$selectedRow_name <- renderPrint({
req(values$selectedRow)
if (is.null( values$selectedRow )) {
"Click on a cell in the heatmap to look an individual row (compound)"
} else {
# paste0(rownames(mat) %>% .[values$selectedRow])
paste0(values$selectedRow %>% refs$name[.])
}
})
# Make scatterplot
output$scatterScores <- renderPlotly({ ####
# Check that a row was selected
req(values$selectedRow)
# Subset the matrix
mat.sel <- mat[values$selectedRow, , drop = F]
# Return the scatterplot of scores x samples
drawScatterScores(mat.sel, dropRowNames = T, source.name = 'scatter') %>%
event_register('plotly_selected')
})
# Gather scatterplot selection if changed
selectedCols <- reactive({
# Get the column (sample) selection from the scatterplot
select.box <- event_data("plotly_selected",
source = "scatter",
priority = "event") # this will reset to null with new ref
selectedCols <- select.box$x
# Which samples? - is there a sample selection? ####
if (is.null(selectedCols)) {return(NULL)}
# Report that columns were selected
message('Selected ', length(selectedCols), ' samples...')
# Return the column inds
selectedCols
})
# Update in reactive variable as well
observeEvent(selectedCols(),{
values$selectedCols <- selectedCols()
})
####### Left-side stuff  ######
# Plot selected ref, record region selection in event_register ####
output$ref.plot = renderPlotly({
req(values$selectedRow)
if (is.null(values$selectedRow)) {message('null row selection'); return(NULL)}
# The lib.data.processed is filtered, but not ordered. Use inds.
ref <- lib.data.processed[[ values$selectedRow %>% refs$number[.] ]]
# Plot all the features with their cluster assignments
plot_spec(ref$mapped$data, ref$mapped$ppm, aucs = NULL, title = ref$compound.name, source.name = 'refspec') %>%
layout(dragmode = "zoom") %>%
event_register(event = "plotly_brushed")
})
output$ref.plot.title <- renderPrint({
req(values$selectized)
if (is.null(values$selectized)){return(NULL)}
paste0("Reference Spectrum for ", values$selectized)
})
# Get the ref range selection from the ref plot, if updated
selectedRange <- reactive({
# Identify selected ppm range within ref - is there a selected range in the ref plot?? ####
sel.range <- event_data(source = 'refspec',
event = "plotly_brushed",
priority = "event") # this will reset to null with new ref
if (is.null(sel.range)){return(NULL)} # and null will be returned
selectedRange <- sel.range$x[1:2] # ppm units
message('selected ref region : ', round(selectedRange[1], 3), '-', round(selectedRange[2], 3), ' ppm')
selectedRange
})
# Update in reactive variable as well
observeEvent(selectedRange(),{
values$selectedRange <- selectedRange()
})
# Feature Plot: plot a stack plot for each group of overlapping ref feats mapped to bounds ####
output$stackplotTitle <- renderText({
req(values$selectedRange)
if (is.null( values$selectedRange )) {
"Click on a cell in the heatmap to look an individual row (compound)"
} else {
paste0("Ref-feature backfits to spectra for ",
paste0(round(values$selectedRange[1], 3), '-', round(values$selectedRange[2], 3)), ' ppm')
}
})
# Feat plot stuff ####
output$state.description <- renderText({
if (is.null(values$selectedRange))
{
sel.rng <- values$selectedRange
} else {
sel.rng <- round(values$selectedRange, 3)
sel.rng <- paste0(sel.rng[1], '-', sel.rng[2], ' ppm')
}
paste0('\n\tselected row (compound): ', values$selectedRow %>% refs$name[.],
'\n\tselected cols: ', length(values$selectedCols),
'\n\tselectedRange: ', sel.rng)
})
output$stack.ref.feats <- renderPlot({
# Check we have the necessary filters ####
req(values$selectedRow)
req(values$selectedCols)
req(values$selectedRange)
req(ppm.tolerance)
req(vshift)
req(hshift)
message('\n\nTrying stackplot for')
# Which compound? ####
if (is.null(values$selectedRow)) {return(NULL)}
message('\t', values$selectedRow %>% refs$name[.])
# Which samples? - is there a sample selection? ####
if (is.null(values$selectedCols)) {return(NULL)}
message('\tin ', length(values$selectedCols), ' samples...')
# If all those pieces are in place, go on to selecting evidence: ####
metab.evidence <- select.evidence_refmet(ref = values$selectedRow %>% refs[.,],
sample = values$selectedCols %>% samples[.,],
# Big objects to subset using ref.ind:
match.info,
backfits,
rfs.used, # new object with inds of rfs which contributed to scores
lib.data.processed,
# # Spectral data:
#   xmat, ppm,
# Filtering thresholds:
ppm.tolerance = ppm.tolerance,
cutoff.residuals.feat = cutoff.residuals.feat,
cutoff.residuals.spec = cutoff.residuals.spec)
rf.fits <- metab.evidence$rf.fits
# Does any evidence exist for that ref in those samples?? ####
if(is.null(rf.fits)){message('\tno evidence for this region'); return(NULL)
} #else {message('\tselected ', length(rf.fits$fit.xrow), ' spec-features.')}
# Which ref feats ranges intersect selected ppm rng within tolerance? ####
# message('\t', c(rf.fits$fit.rngs) %>% range %>% round(3) %>% paste(., collapse = " - "), ' ppm')
out.of.range <- apply(rf.fits$fit.rngs, 2, function(rf.rng)
{range.intersect(rf.rng, values$selectedRange) %>% is.na %>% all}) %>% unlist
in.range <- !out.of.range
# Plot the backfit stackplot ref features that matched to those ppm points ####
if (any(in.range)){
message('Plotting ', sum(in.range), ' ref-feature x spectrum associations\n',
'\tfor region ',
round(values$selectedRange[1], 3), '-', round(values$selectedRange[2], 3), ' ppm\n',
'\tin ', length(values$selectedCols), ' samples...\n',
'\tPlease wait (plotting more spectra and/or wider regions takes more time)...\n')
bfs <- list(fit.feats = rf.fits$fit.feats[in.range, , drop = F],
fit.positions = rf.fits$fit.positions[in.range, , drop = F],
fit.xrow = rf.fits$fit.xrow[in.range],
pass.fit = T)
# Compute the feature stackplots ####
plt.pars <- list(vshift = 1, pixels = c(512, 512), pointsize = 0, interpolate = T, exp.by = 0.05)
# bfs$fit.feats <- bfs$fit.feats[1:71,]
# bfs$fit.positions <- bfs$fit.positions[1:71,]
# bfs$fit.xrow <- bfs$fit.xrow[1:71]
return(
fastStack.withFeatures(xmat, ppm, raster = T, bfs = bfs, plt.pars)
)
# p <- project_features.stackplot(xmat, ppm,
#                                  label = NULL,
#                                  bestfits = bfs,
#                                  exp.by = 0.05, # ppm
#                                  vshift = vshift, # pass as slide bar?
#                                  hshift = hshift, # pass as slide bar?
#                                  sort.rows = F)
}
message("\tnothing in range (+\\- ppm match tolerance; ", ppm.tolerance,')...'); return(NULL)
})
####### Server-side compound selectizing ####
# Update selectizer ####
observeEvent(input$outputType, # look in outputType (from selectInput)
{
if(req(input$outputType == "Search for compound...")){
updateSelectizeInput(session,"compound.selection",
"Type/Select metabolite name (first one will be used)",
choices=unique(refs$name), server=T,
options = list(maxOptions = 5,
maxItems = 1,
placeholder = 'Start typing...'))
# Set working values based on this selection
output$selectized.compound <- renderText({paste0('selectized: ', input$compound.selection)})
}
}
)
# Get value from selectizer choice, map to row index ####
observeEvent(input$compound.selection, {
message("selectizer: ", input$compound.selection)
selectedRows <- which(refs$name == input$compound.selection) # in terms of matrix row inds
if (length(selectedRows) == 0){
message('compound name mismatch?')
values$selectedRow <- NULL
}
if (length(selectedRows) > 1){
message('Multiple compounds have name: ', refs$name[selectedRows[1]])
message('\tchoosing one with best overall score...')
row.bestscore <- mat[selectedRows, , drop = F] %>% rowSums %>% which.max %>% selectedRows[.]
message('Row ', row.bestscore, ' selected')
values$selectedRow <- row.bestscore
} else {
message('Row ', selectedRows[1], ' selected')
values$selectedRow <- selectedRows[1]
}
# Reset plotly data for our feeder plots
values$selectedCols <- NULL
values$selectedRange <- NULL
})
}
shinyApp(ui, server)
