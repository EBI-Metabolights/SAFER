source("~/Documents/GitHub/icl_nmr_R/R/match.features2refs.par.explicit.R")
source("~/Documents/GitHub/icl_nmr_R/R/filter.matches_singlets.R")
tmpdir <- pars$dirs$temp
this.run <- paste0(tmpdir)
setwd('/Users/mjudge/Documents/GitHub/icl_nmr_R')
devtools::document()
run_params <- '/Users/mjudge/Documents/current_run/params.yaml'
pars <- yaml::yaml.load_file(run_params, eval.expr = TRUE)
tmpdir <- pars$dirs$temp
this.run <- paste0(tmpdir)
message("Loading data from files...\n\n\n")
fse.result <- readRDS(paste0(this.run, "/fse.result.RDS"))
xmat <- fse.result$xmat
ppm <- fse.result$ppm
rm(fse.result)
feature <- readRDS(paste0(this.run, "/feature.final.RDS"))
ref.mat <- readRDS(paste0(this.run, "/temp_data_matching/ref.mat.RDS"))
matches <- readRDS(paste0(this.run, "/matches.RDS"))
cluster <- readRDS(paste0(this.run, "/cluster.final.RDS"))
matches.split <- split(matches, names(matches))
rm(matches)
match.info <- do.call(rbind, matches.split$matches)
rownames(match.info) <- NULL
# peak.qualities aligns with fit and match.info now, but feat number does not index it (there are missing features)!
pq.featureNumbers <- unique(match.info[,'feat']) # this does not sort (just for good measure)
peak.qualities <- matches.split$peak.quality
# fits.feature <- matches.split$fits %>% unlist(recursive = F)
rm(matches.split)
fits.feature <- matches.split$fits %>% unlist(recursive = F)
matches <- readRDS(paste0(this.run, "/matches.RDS"))
tmpdir <- '/Users/mjudge/Documents/current_run_5'#pars$dirs$temp
this.run <- paste0(tmpdir)
message("Loading data from files...\n\n\n")
fse.result <- readRDS(paste0(this.run, "/fse.result.RDS"))
xmat <- fse.result$xmat
ppm <- fse.result$ppm
rm(fse.result)
feature <- readRDS(paste0(this.run, "/feature.final.RDS"))
ref.mat <- readRDS(paste0(this.run, "/temp_data_matching/ref.mat.RDS"))
matches <- readRDS(paste0(this.run, "/matches.RDS"))
cluster <- readRDS(paste0(this.run, "/cluster.final.RDS"))
matches.split <- split(matches, names(matches))
rm(matches)
match.info <- do.call(rbind, matches.split$matches)
rownames(match.info) <- NULL
# peak.qualities aligns with fit and match.info now, but feat number does not index it (there are missing features)!
pq.featureNumbers <- unique(match.info[,'feat']) # this does not sort (just for good measure)
peak.qualities <- matches.split$peak.quality
fits.feature <- matches.split$fits %>% unlist(recursive = F)
# Do the filtering (functionalized)
res <- filter.matches_singlets(match.info, fits.feature,
peak.qualities, pq.featureNumbers,
pars$matching$filtering$res.area.threshold)
message('filtering out matches for fit features with 1 or fewer resonances...')
########### singlet filter for fit features ################
mi <- match.info[m, ]
m <- 1
########### singlet filter for fit features ################
mi <- match.info[m, ]
ff <- apply.fit(mi, feature, ref.mat)
mi
ff <- apply.fit(mi.row = mi, feat.stack = feature$stack, ref.stack = ref.mat)
mi$numpeaks.feat <- pk.maxs(ff$feat.fit, mask = !is.na(ff$residuals)) %>% length
mi$numpeaks.feat
mask <- !is.na(ff$residuals)
mask <- !is.na(ff$residuals)
mi$numpeaks.feat <- pk.maxs(ff$feat.fit, mask) %>% length
mi$numpeaks.ref <- pk.maxs(ff$spec.fit, mask) %>% length
peak.quality <- peak.qualities[[which(match.info[m,'feat'] == pq.featureNumbers)]]
f.adj <- ff$feat.fit - ff$feat.fit * peak.quality
f.adj <- f.adj - min(f.adj, na.rm = T)
mi$numpeaks.feat.nnf <- pk.maxs(f.adj, mask = !is.na(f.adj)) %>% length # not sure if mask here is always the same as above
extractPeaks_corr(ff$spec.fit,plots = T)
pk.coverage <- lapply(pks$bounds[pks$truePeak], function(p){
pkinds <- p %>% unlist %>% fillbetween
return(sum(ff$feat.fit[pkinds],na.rm = T) / sum(ff$spec.fit[pkinds],na.rm = T))
})
pks <- extractPeaks_corr(ff$spec.fit,plots = F)
pk.coverage <- lapply(pks$bounds[pks$truePeak], function(p){
pkinds <- p %>% unlist %>% fillbetween
return(sum(ff$feat.fit[pkinds],na.rm = T) / sum(ff$spec.fit[pkinds],na.rm = T))
})
mi$refpeaks.matched <- sum(pk.coverage > (1-res.area.threshold) & pk.coverage < (1+res.area.threshold))
res.area.threshold <- res.area.threshol
res.area.threshold <- res.area.thresh
mi$refpeaks.matched <- sum(pk.coverage > (1-res.area.threshold) & pk.coverage < (1+res.area.threshold))
mi$refpeaks.matched
message('filtering out matches:',
'\n\t- for fit features with 1 or fewer resonances...',
'\n\t- involving ref features with 1 or fewer resonances...',
'\n\t- involving not-never-fit feature regions with 1 or fewer resonances...',
'\n\t- for which 1 or fewer resonances had at least ', pars$matching$filtering$res.area.threshold,
' of their area explained by the matching feature...')
# Apply singlet filters to each mi row, and add the results as fields.
match.info <- pblapply(1:10, function(m){
########### singlet filter for fit features ################
mi <- match.info[m, ]
ff <- apply.fit(mi.row = mi, feat.stack = feature$stack, ref.stack = ref.mat)
mask <- !is.na(ff$residuals)
mi$numpeaks.feat <- pk.maxs(ff$feat.fit, mask) %>% length
########### singlet filter for fit ref regions ################
mi$numpeaks.ref <- pk.maxs(ff$spec.fit, mask) %>% length
########### singlet filter for feature-not-never-fit regions ################
peak.quality <- peak.qualities[[which(match.info[m,'feat'] == pq.featureNumbers)]]
f.adj <- ff$feat.fit - ff$feat.fit * peak.quality
f.adj <- f.adj - min(f.adj, na.rm = T)
mi$numpeaks.feat.nnf <- pk.maxs(f.adj, mask = !is.na(f.adj)) %>% length # not sure if mask here is always the same as above
########### singlet filter for refpeaks.matched ################
pks <- extractPeaks_corr(ff$spec.fit,plots = F)
pk.coverage <- lapply(pks$bounds[pks$truePeak], function(p){
pkinds <- p %>% unlist %>% fillbetween
return(sum(ff$feat.fit[pkinds],na.rm = T) / sum(ff$spec.fit[pkinds],na.rm = T))
})
mi$refpeaks.matched <- sum(pk.coverage > (1-res.area.threshold) & pk.coverage < (1+res.area.threshold))
return(mi)
})
match.info <- rbindlist(match.info)
View(match.info)
source("~/Documents/GitHub/icl_nmr_R/R/filter.matches_singlets.R")
nrow(match.info)
# Apply singlet filters to each mi row, and add the results as fields.
match.info <- lapply(1:nrow(match.info), function(m){
########### singlet filter for fit features ################
mi <- match.info[m, ]
ff <- apply.fit(mi.row = mi, feat.stack = feature$stack, ref.stack = ref.mat)
mask <- !is.na(ff$residuals)
mi$numpeaks.feat <- pk.maxs(ff$feat.fit, mask) %>% length
########### singlet filter for fit ref regions ################
mi$numpeaks.ref <- pk.maxs(ff$spec.fit, mask) %>% length
########### singlet filter for feature-not-never-fit regions ################
peak.quality <- peak.qualities[[which(match.info[m,'feat'] == pq.featureNumbers)]]
f.adj <- ff$feat.fit - ff$feat.fit * peak.quality
f.adj <- f.adj - min(f.adj, na.rm = T)
mi$numpeaks.feat.nnf <- pk.maxs(f.adj, mask = !is.na(f.adj)) %>% length # not sure if mask here is always the same as above
########### singlet filter for refpeaks.matched ################
pks <- extractPeaks_corr(ff$spec.fit,plots = F)
pk.coverage <- lapply(pks$bounds[pks$truePeak], function(p){
pkinds <- p %>% unlist %>% fillbetween
return(sum(ff$feat.fit[pkinds],na.rm = T) / sum(ff$spec.fit[pkinds],na.rm = T))
})
mi$refpeaks.matched <- sum(pk.coverage > (1-res.area.threshold) & pk.coverage < (1+res.area.threshold))
########### Return row #########
return(mi)
})#, mc.cores = pars$par$ncores)
match.info <- rbindlist(match.info)
match.info <- filter(match.info,
numpeaks.feat > 1 &
numpeaks.ref > 1 &
numpeaks.feat.nnf > 1 &
refpeaks.matched > 1)
numpeaks.feat > 1
message(nrow(match.info), ' matches remaining\n\n')
source("~/Documents/GitHub/icl_nmr_R/R/filter.matches_singlets.R")
source("~/Documents/GitHub/icl_nmr_R/R/filter.matches_singlets.R")
source("~/Documents/GitHub/icl_nmr_R/R/filter.matches_singlets.R")
source("~/Documents/GitHub/icl_nmr_R/R/filter.matches.R")
