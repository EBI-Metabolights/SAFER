% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match.features2refs.par.R
\name{match.features2refs.par}
\alias{match.features2refs.par}
\title{Match STORM features to GISSMO database using parallel computing}
\usage{
match.features2refs.par(pars)
}
\arguments{
\item{pars}{a list of parameters for matching, read in from a YAML file}
}
\value{
nothing; results are saved as an RDS file
}
\description{
This function matches STORM'd feature shapes to a reference database using cross-correlation,
least-squares fitting, and peak quality weighting. The matching process is parallelized
for speed, and results are saved as an RDS file. The function reads in parameters from
a YAML file and data from RDS files generated by previous function calls (from fse() and tina())
}
\details{
Matching:
Matching is accomplished by cross-correlating all pairwise feature - reference 
spectrum pairs. Since there are feature-level comparisons to make (i.e. a single
feature across all matches), iteration over features is serial. Iteration over
references for each feature is done in parallel. This comparison is not optimal,
but works as a proof of concept and can be scaled up. Increasing numbers of 
features results in a linear increase in computational time, but also more memory 
usage for each core. Generally, it is advisable to leave 1 or 2 cores on one's 
machine free for system operations and the main R instance. For each comparison 
that is, for each feature - reference pair being tested, the top max.hits 
(e.g., 5) convolution hits are assessed for pearson correlation coefficient 
(r.thresh) and pvalue (p.thresh). For hits passing both thresholds, the feature
is fit to the reference using least squares. RMSE is reported. 

Next, it's best to avoid penalizing a feature fit just because it contains false 
positive points. Once a feature has been fit to all reference spectra (at 0-5  
more places), resonances which were never fit are identified using peak poorness:
1) Line up all fits for that feature across the database. 
2) For each fit, take the positive residuals, divide by feature intensity. If 
   values are close to 1, the feature was completely absent in the ref
   signature at those point. This is a measure of ~ peak poorness for this database
3) Take the mean of those values across all fits for each point in the feature. 
4) Square peak-poorness to squash them down unless very high:
    peak.quality = 1-(peak.poorness^2)
5) For each fit's non-missing values:
    rmse.weighted = sum(residuals * peak.quality)/n.points
    
This metric appears to give more intuitive results. Missing reference resonances
compared to the feature is preferable to the opposite, which will be measured 
during backfitting.
Matches are written to file. 
Note: matching in parallel is much lighter (~50%) if run in a new R instance  
outside of RStudio due to memory leaks/overhead.
}
